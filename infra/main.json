{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_generator": {
      "name": "bicep",
      "version": "0.39.26.7824",
      "templateHash": "8189209922411740627"
    }
  },
  "parameters": {
    "namePrefix": {
      "type": "string",
      "minLength": 3,
      "maxLength": 12,
      "metadata": {
        "description": "Prefix applied to most resource names."
      }
    },
    "location": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "Azure region for all resources."
      }
    },
    "pdsHostname": {
      "type": "string",
      "minLength": 4,
      "maxLength": 253,
      "metadata": {
        "description": "Fully qualified hostname clients use to reach the PDS (e.g. pds.example.com)."
      }
    },
    "pdsImageTag": {
      "type": "string",
      "minLength": 1,
      "maxLength": 128,
      "metadata": {
        "description": "Container image tag for ghcr.io/bluesky-social/pds (e.g. 0.4)."
      }
    },
    "certificateResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Resource ID of an existing Container Apps certificate (managed certificate or uploaded cert) to bind to the ingress. Leave empty to skip custom domain binding."
      }
    },
    "enableCustomDomain": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Whether to enable custom domain binding with the provided certificate."
      }
    },
    "pdsCpu": {
      "type": "string",
      "defaultValue": "0.25",
      "metadata": {
        "description": "CPU request for the PDS container in cores."
      }
    },
    "pdsMemory": {
      "type": "string",
      "defaultValue": "0.5Gi",
      "metadata": {
        "description": "Memory request for the PDS container."
      }
    },
    "enableHttp": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Whether to allow unauthenticated HTTP (port 80) alongside HTTPS."
      }
    },
    "minReplicas": {
      "type": "int",
      "defaultValue": 1,
      "metadata": {
        "description": "Minimum number of replicas the container app should maintain."
      }
    },
    "maxReplicas": {
      "type": "int",
      "defaultValue": 2,
      "metadata": {
        "description": "Maximum number of replicas the container app may scale to."
      }
    },
    "pdsJwtSecretName": {
      "type": "string",
      "minLength": 1,
      "maxLength": 127,
      "metadata": {
        "description": "Name of the Key Vault secret containing the PDS JWT secret."
      }
    },
    "pdsAdminPasswordSecretName": {
      "type": "string",
      "minLength": 1,
      "maxLength": 127,
      "metadata": {
        "description": "Name of the Key Vault secret containing the PDS admin password."
      }
    },
    "pdsPlcRotationKeySecretName": {
      "type": "string",
      "minLength": 1,
      "maxLength": 127,
      "metadata": {
        "description": "Name of the Key Vault secret containing the PLC rotation key (hex)."
      }
    },
    "smtpSecretName": {
      "type": "string",
      "defaultValue": "PDS-SMTP-URL",
      "minLength": 1,
      "maxLength": 127,
      "metadata": {
        "description": "Name of the Key Vault secret containing the SMTP connection string or password."
      }
    },
    "emailFromAddressSecretName": {
      "type": "string",
      "defaultValue": "PDS-EMAIL-FROM-ADDRESS",
      "minLength": 1,
      "maxLength": 127,
      "metadata": {
        "description": "Name of the Key Vault secret containing the computed email from address."
      }
    },
    "emailFromAddress": {
      "type": "string",
      "defaultValue": "",
      "maxLength": 320,
      "metadata": {
        "description": "From address to use when PDS sends email. Leave empty to auto-use Azure-managed domain when enableCommunicationServices=true."
      }
    },
    "enableCommunicationServices": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Whether to provision Azure Communication Services for email sending."
      }
    },
    "emailCustomDomain": {
      "type": "string",
      "defaultValue": "",
      "maxLength": 253,
      "metadata": {
        "description": "Custom domain name for Azure Communication Services Email (e.g. notify.example.com). Leave empty to use Azure-managed domain."
      }
    },
    "adminObjectId": {
      "type": "string",
      "minLength": 36,
      "maxLength": 36,
      "metadata": {
        "description": "Object ID for an administrator that should have full access to the Key Vault."
      }
    },
    "dnsZoneName": {
      "type": "string",
      "defaultValue": "",
      "maxLength": 253,
      "metadata": {
        "description": "Optional DNS zone name (e.g. example.com). Leave empty to skip DNS record creation."
      }
    },
    "dnsRecordName": {
      "type": "string",
      "defaultValue": "pds",
      "minLength": 1,
      "maxLength": 63,
      "metadata": {
        "description": "Optional relative record for the container app within the DNS zone (e.g. pds). Ignored when dnsZoneName is empty."
      }
    },
    "logAnalyticsRetentionDays": {
      "type": "int",
      "defaultValue": 30,
      "minValue": 7,
      "maxValue": 730,
      "metadata": {
        "description": "Retention in days for Log Analytics data."
      }
    },
    "snapshotContainerName": {
      "type": "string",
      "defaultValue": "pds-sqlite",
      "minLength": 3,
      "maxLength": 63,
      "metadata": {
        "description": "Name of the blob container used to store SQLite snapshot archives."
      }
    },
    "snapshotPrefix": {
      "type": "string",
      "defaultValue": "snapshots",
      "minLength": 1,
      "metadata": {
        "description": "Prefix applied to snapshot blob paths."
      }
    },
    "backupRetentionCount": {
      "type": "int",
      "defaultValue": 200,
      "minValue": 10,
      "metadata": {
        "description": "Number of snapshot archives to retain in object storage."
      }
    },
    "pdsDidPlcUrl": {
      "type": "string",
      "defaultValue": "https://plc.directory",
      "metadata": {
        "description": "URL for the PLC directory service."
      }
    },
    "pdsBskyAppViewUrl": {
      "type": "string",
      "defaultValue": "https://api.bsky.app",
      "metadata": {
        "description": "URL for the Bluesky API service."
      }
    },
    "pdsBskyAppViewDid": {
      "type": "string",
      "defaultValue": "did:web:api.bsky.app",
      "metadata": {
        "description": "DID for the Bluesky API service."
      }
    },
    "pdsReportServiceUrl": {
      "type": "string",
      "defaultValue": "https://mod.bsky.app",
      "metadata": {
        "description": "URL for the Bluesky report service."
      }
    },
    "pdsReportServiceDid": {
      "type": "string",
      "defaultValue": "did:plc:ar7c4by46qjdydhdevvrndac",
      "metadata": {
        "description": "DID for the Bluesky report service."
      }
    },
    "pdsCrawlers": {
      "type": "string",
      "defaultValue": "https://bsky.network",
      "metadata": {
        "description": "Crawlers to whitelist for indexing (comma-separated URLs)."
      }
    }
  },
  "variables": {
    "tenantId": "[subscription().tenantId]",
    "pdsImage": "[format('ghcr.io/bluesky-social/pds:{0}', parameters('pdsImageTag'))]",
    "cleanedNamePrefix": "[replace(format('{0}{1}', parameters('namePrefix'), uniqueString(resourceGroup().id)), '-', '')]",
    "storageAccountName": "[toLower(if(greater(length(variables('cleanedNamePrefix')), 24), substring(variables('cleanedNamePrefix'), 0, 24), variables('cleanedNamePrefix')))]",
    "containerAppName": "[format('{0}-pds-app', parameters('namePrefix'))]",
    "containerAppIdentityName": "[format('{0}-pds-id', parameters('namePrefix'))]",
    "keyVaultName": "[format('{0}-{1}-kv', parameters('namePrefix'), uniqueString(resourceGroup().id))]",
    "logAnalyticsName": "[format('{0}-law', parameters('namePrefix'))]",
    "managedEnvName": "[format('{0}-cae', parameters('namePrefix'))]",
    "hasCustomDomainBinding": "[and(parameters('enableCustomDomain'), greater(length(parameters('certificateResourceId')), 0))]",
    "ingressCustomDomains": "[if(variables('hasCustomDomainBinding'), createArray(createObject('name', parameters('pdsHostname'), 'certificateId', parameters('certificateResourceId'), 'bindingType', 'SniEnabled')), createArray())]",
    "storageAccountKeySecretName": "storage-account-key",
    "communicationServiceName": "[format('{0}-acs', parameters('namePrefix'))]",
    "emailServiceName": "[format('{0}-email', parameters('namePrefix'))]",
    "hasEmailFromOverride": "[greater(length(parameters('emailFromAddress')), 0)]",
    "includeSmtpSecret": "[greater(length(parameters('smtpSecretName')), 0)]",
    "backupRestoreScriptContent": "#!/usr/bin/env sh\nset -euo pipefail\n\n# Restore script using Azure Storage REST API (curl + openssl)\n\nDATA_DIR=${DATA_DIR:-/data}\nWORK_DIR=${WORK_DIR:-/work}\nSNAPSHOT_CONTAINER=${SNAPSHOT_CONTAINER:-pds-sqlite}\nSNAPSHOT_PREFIX=${SNAPSHOT_PREFIX:-snapshots}\nACCOUNT_NAME=${AZURE_STORAGE_ACCOUNT_NAME:?AZURE_STORAGE_ACCOUNT_NAME is required}\nACCOUNT_KEY=${AZURE_STORAGE_ACCOUNT_KEY:?AZURE_STORAGE_ACCOUNT_KEY is required}\nPDS_ID=${PDS_ID:-default}\nSENTINEL_PATH=${SENTINEL_PATH:-\"$DATA_DIR/.restore-complete\"}\nDOWNLOAD_PATH=\"$WORK_DIR/restore.tar.zst\"\n\nmkdir -p \"$DATA_DIR\" \"$WORK_DIR\"\n\nif [ -f \"$DATA_DIR/pds.sqlite\" ] || [ -d \"$DATA_DIR/actors\" ]; then\n  echo \"[restore] Data directory already populated; skipping snapshot restore.\"\n  touch \"$SENTINEL_PATH\"\n  exit 0\nfi\n\nif [ -f \"$SENTINEL_PATH\" ]; then\n  echo \"[restore] Restore sentinel exists; skipping snapshot restore.\"\n  exit 0\nfi\n\nbin2hex() {\n  od -A n -t x1 | tr -d ' \\n'\n}\n\nsign_request() {\n  local method=$1\n  local resource=$2\n  local query_params=$3\n  local headers=$4\n  local content_length=${5:-}\n  local content_type=${6:-}\n  \n  local date=$(date -u +\"%a, %d %b %Y %H:%M:%S GMT\")\n  local version=\"2021-06-08\"\n  \n  local canon_headers=\"x-ms-date:$date\\nx-ms-version:$version\"\n  local canon_res=\"/$ACCOUNT_NAME$resource\"\n  if [ -n \"$query_params\" ]; then\n    canon_res=\"$canon_res\\n$query_params\"\n  fi\n  \n  local string_to_sign=\"$method\\n\\n\\n$content_length\\n\\n$content_type\\n\\n\\n\\n\\n\\n\\n$canon_headers\\n$canon_res\"\n  local hex_key=$(echo -n \"$ACCOUNT_KEY\" | base64 -d | bin2hex)\n  local signature=$(echo -n -e \"$string_to_sign\" | openssl dgst -sha256 -mac HMAC -macopt hexkey:\"$hex_key\" -binary | base64 -w 0)\n  \n  echo \"Authorization: SharedKey $ACCOUNT_NAME:$signature\"\n  echo \"x-ms-date: $date\"\n  echo \"x-ms-version: $version\"\n}\n\necho \"[restore] Looking for latest snapshot in container '$SNAPSHOT_CONTAINER' with prefix '$SNAPSHOT_PREFIX/$PDS_ID'\"\n\n# List Blobs\n# CanonicalizedResource: /account/container\\ncomp:list\\nprefix:...\\nrestype:container\nprefix=\"$SNAPSHOT_PREFIX/$PDS_ID/\"\nquery_params=\"comp:list\\nprefix:$prefix\\nrestype:container\"\nauth_output=$(sign_request \"GET\" \"/$SNAPSHOT_CONTAINER\" \"$query_params\" \"\")\nauth_header=$(echo \"$auth_output\" | grep \"Authorization:\")\ndate_header=$(echo \"$auth_output\" | grep \"x-ms-date:\")\nversion_header=$(echo \"$auth_output\" | grep \"x-ms-version:\")\n\nlist_url=\"https://$ACCOUNT_NAME.blob.core.windows.net/$SNAPSHOT_CONTAINER?restype=container&comp=list&prefix=$prefix\"\n\n# Capture HTTP status code and body\n# We use a temporary file for the body to avoid pipe masking exit codes and to separate body from status\nresponse_body_file=$(mktemp)\nhttp_code=$(curl -s -w \"%{http_code}\" -X GET \\\n  -H \"$auth_header\" \\\n  -H \"$date_header\" \\\n  -H \"$version_header\" \\\n  -o \"$response_body_file\" \\\n  \"$list_url\")\n\nif [ \"$http_code\" != \"200\" ]; then\n  echo \"[restore] ERROR: Failed to list blobs. HTTP Status: $http_code\"\n  echo \"[restore] Response body:\"\n  cat \"$response_body_file\"\n  rm -f \"$response_body_file\"\n  exit 1\nfi\n\nlist_response=$(cat \"$response_body_file\")\nrm -f \"$response_body_file\"\n\n# Extract latest blob\n# Note: Alpine grep doesn't support -P, so we use sed\nLATEST_BLOB=$(echo \"$list_response\" | sed -n 's/.*<Name>\\(.*\\)<\\/Name>.*/\\1/p' | grep \"$SNAPSHOT_PREFIX/$PDS_ID/\" | sort | tail -1 || true)\n\nif [ -z \"${LATEST_BLOB:-}\" ]; then\n  # Check if the response was actually a valid empty list (contains <Blobs /> or <Blobs></Blobs> or just <Blobs>)\n  # If it's a valid XML response but no blobs match, that's fine.\n  # But if we got 200 OK, it should be valid XML.\n  echo \"[restore] No snapshots found matching prefix '$SNAPSHOT_PREFIX/$PDS_ID/'; starting with empty state.\"\n  touch \"$SENTINEL_PATH\"\n  exit 0\nfi\n\necho \"[restore] Downloading snapshot blob $LATEST_BLOB\"\n\n# Download Blob\nauth_output=$(sign_request \"GET\" \"/$SNAPSHOT_CONTAINER/$LATEST_BLOB\" \"\" \"\")\nauth_header=$(echo \"$auth_output\" | grep \"Authorization:\")\ndate_header=$(echo \"$auth_output\" | grep \"x-ms-date:\")\nversion_header=$(echo \"$auth_output\" | grep \"x-ms-version:\")\n\ncurl -s -X GET \\\n  -H \"$auth_header\" \\\n  -H \"$date_header\" \\\n  -H \"$version_header\" \\\n  -o \"$DOWNLOAD_PATH\" \\\n  \"https://$ACCOUNT_NAME.blob.core.windows.net/$SNAPSHOT_CONTAINER/$LATEST_BLOB\"\n\nif [ ! -s \"$DOWNLOAD_PATH\" ]; then\n  echo \"[restore] Downloaded archive is empty; aborting.\"\n  exit 1\nfi\n\necho \"[restore] Extracting archive into $DATA_DIR\"\nrm -rf \"$DATA_DIR\"/*\nzstd -d -c \"$DOWNLOAD_PATH\" | tar -x -C \"$DATA_DIR\"\n\ntouch \"$SENTINEL_PATH\"\necho \"[restore] Restore complete.\"",
    "backupJobScriptContent": "#!/usr/bin/env sh\nset -euo pipefail\n\nDATA_DIR=${DATA_DIR:-/data}\nWORK_DIR=${WORK_DIR:-/work}\nACCOUNT_NAME=${AZURE_STORAGE_ACCOUNT_NAME:?AZURE_STORAGE_ACCOUNT_NAME is required}\nACCOUNT_KEY=${AZURE_STORAGE_ACCOUNT_KEY:?AZURE_STORAGE_ACCOUNT_KEY is required}\nSNAPSHOT_CONTAINER=${SNAPSHOT_CONTAINER:-pds-sqlite}\nSNAPSHOT_PREFIX=${SNAPSHOT_PREFIX:-snapshots}\nPDS_ID=${PDS_ID:-default}\nINTERVAL_SECONDS=${INTERVAL_SECONDS:-15}\nRETAIN_COUNT=${RETAIN_COUNT:-200}\nSENTINEL_PATH=${SENTINEL_PATH:-\"$DATA_DIR/.restore-complete\"}\n\nmkdir -p \"$WORK_DIR\"\n\ncleanup() {\n  rm -rf \"$WORK_DIR\"/snapshot-* \"$WORK_DIR\"/archive-*.tar.zst 2>/dev/null || true\n}\ntrap cleanup EXIT INT TERM\n\nwait_for_restore() {\n  while [ ! -f \"$SENTINEL_PATH\" ]; do\n    echo \"[backup] Waiting for restore sentinel at $SENTINEL_PATH\"\n    sleep 2\n  done\n}\n\nbin2hex() {\n  od -A n -t x1 | tr -d ' \\n'\n}\n\n# $1: method, $2: resource (e.g. /container/blob), $3: query params (newlines separated key:value), $4: headers (newlines separated key:value), $5: content-length, $6: content-type\nsign_request() {\n  local method=$1\n  local resource=$2\n  local query_params=$3\n  local headers=$4\n  local content_length=${5:-}\n  local content_type=${6:-}\n  \n  local date=$(date -u +\"%a, %d %b %Y %H:%M:%S GMT\")\n  local version=\"2021-06-08\"\n  \n  # Build CanonicalizedHeaders\n  # We assume only x-ms-date and x-ms-version and maybe x-ms-blob-type are used.\n  # Sort headers?\n  local canon_headers=\"\"\n  if echo \"$headers\" | grep -q \"x-ms-blob-type\"; then\n    local blob_type=$(echo \"$headers\" | grep \"x-ms-blob-type\" | cut -d: -f2 | tr -d ' ')\n    canon_headers=\"x-ms-blob-type:$blob_type\\n\"\n  fi\n  canon_headers=\"${canon_headers}x-ms-date:$date\\nx-ms-version:$version\"\n  \n  # Build CanonicalizedResource\n  local canon_res=\"/$ACCOUNT_NAME$resource\"\n  if [ -n \"$query_params\" ]; then\n    # Sort query params? We assume caller passes them sorted if needed, or we just append.\n    # Azure requires lexicographical order.\n    canon_res=\"$canon_res\\n$query_params\"\n  fi\n  \n  local string_to_sign=\"$method\\n\\n\\n$content_length\\n\\n$content_type\\n\\n\\n\\n\\n\\n\\n$canon_headers\\n$canon_res\"\n  \n  local hex_key=$(echo -n \"$ACCOUNT_KEY\" | base64 -d | bin2hex)\n  local signature=$(echo -n -e \"$string_to_sign\" | openssl dgst -sha256 -mac HMAC -macopt hexkey:\"$hex_key\" -binary | base64 -w 0)\n  \n  echo \"Authorization: SharedKey $ACCOUNT_NAME:$signature\"\n  echo \"x-ms-date: $date\"\n  echo \"x-ms-version: $version\"\n}\n\nsnapshot_iteration() {\n  TS=$(date -u +\"%Y%m%d-%H%M%S\")\n  STAGING=\"$WORK_DIR/snapshot-$TS\"\n  ARCHIVE=\"$WORK_DIR/archive-$TS.tar.zst\"\n\n  rm -rf \"$STAGING\"\n  mkdir -p \"$STAGING\"\n\n  echo \"[backup] Creating staging copy of $DATA_DIR\"\n  tar -C \"$DATA_DIR\" -cf - . | tar -C \"$STAGING\" -xf -\n  find \"$STAGING\" -type f \\( -name \"*.sqlite\" -o -name \"*.sqlite-wal\" -o -name \"*.sqlite-shm\" \\) -delete\n\n  echo \"[backup] Refreshing SQLite backups\"\n  find \"$DATA_DIR\" -type f -name \"*.sqlite\" | while read -r DB; do\n    TARGET=\"$STAGING${DB#$DATA_DIR}\"\n    mkdir -p \"$(dirname \"$TARGET\")\"\n    sqlite3 \"$DB\" \".backup '$TARGET'\"\n  done\n\n  echo \"[backup] Packaging snapshot\"\n  tar -C \"$STAGING\" -I \"zstd -3\" -cf \"$ARCHIVE\" .\n  \n  local blob_name=\"$SNAPSHOT_PREFIX/$PDS_ID/snap-$TS.tar.zst\"\n  local file_size=$(stat -c%s \"$ARCHIVE\")\n  \n  echo \"[backup] Uploading $blob_name ($file_size bytes)\"\n  \n  local auth_output=$(sign_request \"PUT\" \"/$SNAPSHOT_CONTAINER/$blob_name\" \"\" \"x-ms-blob-type:BlockBlob\" \"$file_size\" \"application/x-tar\")\n  local auth_header=$(echo \"$auth_output\" | grep \"Authorization:\")\n  local date_header=$(echo \"$auth_output\" | grep \"x-ms-date:\")\n  local version_header=$(echo \"$auth_output\" | grep \"x-ms-version:\")\n  \n  curl -s -X PUT \\\n    -H \"$auth_header\" \\\n    -H \"$date_header\" \\\n    -H \"$version_header\" \\\n    -H \"x-ms-blob-type: BlockBlob\" \\\n    -H \"Content-Length: $file_size\" \\\n    -H \"Content-Type: application/x-tar\" \\\n    --data-binary @\"$ARCHIVE\" \\\n    \"https://$ACCOUNT_NAME.blob.core.windows.net/$SNAPSHOT_CONTAINER/$blob_name\"\n    \n  # Retention logic omitted for simplicity/robustness in shell.\n  # If we really need it, we can implement List Blobs later.\n  # For now, just uploading is the critical part.\n  echo \"\"\n  echo \"[backup] Upload complete\"\n}\n\nwait_for_restore\n\necho \"[backup] Starting continuous snapshot loop (interval ${INTERVAL_SECONDS}s)\"\nwhile true; do\n  snapshot_iteration || echo \"[backup] Snapshot iteration failed\"\n  cleanup\n  sleep \"$INTERVAL_SECONDS\"\ndone\n",
    "restoreScriptB64": "[base64(variables('backupRestoreScriptContent'))]",
    "backupJobScriptB64": "[base64(variables('backupJobScriptContent'))]",
    "computedEmailFromAddress": "[if(variables('hasEmailFromOverride'), parameters('emailFromAddress'), if(and(parameters('enableCommunicationServices'), not(equals(parameters('emailCustomDomain'), ''))), format('donotreply@{0}', parameters('emailCustomDomain')), if(parameters('enableCommunicationServices'), 'donotreply@placeholder.azurecomm.net', 'donotreply@example.com')))]",
    "smtpPlaceholderValue": "smtps://pending-update@smtp.azurecomm.net:587"
  },
  "resources": [
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "apiVersion": "2018-11-30",
      "name": "[variables('containerAppIdentityName')]",
      "location": "[parameters('location')]"
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces",
      "apiVersion": "2022-10-01",
      "name": "[variables('logAnalyticsName')]",
      "location": "[parameters('location')]",
      "properties": {
        "retentionInDays": "[parameters('logAnalyticsRetentionDays')]",
        "features": {
          "enableLogAccessUsingOnlyResourcePermissions": true
        },
        "sku": {
          "name": "PerGB2018"
        }
      }
    },
    {
      "type": "Microsoft.App/managedEnvironments",
      "apiVersion": "2023-05-01",
      "name": "[variables('managedEnvName')]",
      "location": "[parameters('location')]",
      "properties": {
        "appLogsConfiguration": {
          "destination": "log-analytics",
          "logAnalyticsConfiguration": {
            "customerId": "[reference(resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName')), '2022-10-01').customerId]",
            "sharedKey": "[listKeys(resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName')), '2022-10-01').primarySharedKey]"
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts",
      "apiVersion": "2022-09-01",
      "name": "[variables('storageAccountName')]",
      "location": "[parameters('location')]",
      "sku": {
        "name": "Standard_LRS"
      },
      "kind": "StorageV2",
      "properties": {
        "accessTier": "Hot",
        "minimumTlsVersion": "TLS1_2",
        "supportsHttpsTrafficOnly": true,
        "allowBlobPublicAccess": false,
        "allowSharedKeyAccess": true
      }
    },
    {
      "type": "Microsoft.Storage/storageAccounts/blobServices/containers",
      "apiVersion": "2022-09-01",
      "name": "[format('{0}/default/{1}', variables('storageAccountName'), parameters('snapshotContainerName'))]",
      "properties": {
        "publicAccess": "None"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults",
      "apiVersion": "2023-07-01",
      "name": "[variables('keyVaultName')]",
      "location": "[parameters('location')]",
      "properties": {
        "tenantId": "[variables('tenantId')]",
        "sku": {
          "name": "standard",
          "family": "A"
        },
        "enablePurgeProtection": true,
        "enabledForTemplateDeployment": true,
        "accessPolicies": [
          {
            "tenantId": "[variables('tenantId')]",
            "objectId": "[parameters('adminObjectId')]",
            "permissions": {
              "secrets": [
                "get",
                "list",
                "set",
                "delete",
                "recover",
                "backup",
                "restore"
              ]
            }
          }
        ]
      }
    },
    {
      "type": "Microsoft.App/containerApps",
      "apiVersion": "2023-05-01",
      "name": "[variables('containerAppName')]",
      "location": "[parameters('location')]",
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName')))]": {}
        }
      },
      "properties": {
        "managedEnvironmentId": "[resourceId('Microsoft.App/managedEnvironments', variables('managedEnvName'))]",
        "configuration": {
          "activeRevisionsMode": "Single",
          "ingress": {
            "external": true,
            "targetPort": 2583,
            "allowInsecure": "[parameters('enableHttp')]",
            "transport": "auto",
            "traffic": [
              {
                "latestRevision": true,
                "weight": 100
              }
            ],
            "customDomains": "[variables('ingressCustomDomains')]"
          },
          "secrets": "[concat(createArray(createObject('name', 'pds-jwt-secret', 'keyVaultUrl', format('{0}secrets/{1}', reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri, parameters('pdsJwtSecretName')), 'identity', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))), createObject('name', 'pds-admin-password', 'keyVaultUrl', format('{0}secrets/{1}', reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri, parameters('pdsAdminPasswordSecretName')), 'identity', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))), createObject('name', 'pds-plc-key', 'keyVaultUrl', format('{0}secrets/{1}', reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri, parameters('pdsPlcRotationKeySecretName')), 'identity', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))), createObject('name', 'pds-email-from-address', 'keyVaultUrl', format('{0}secrets/{1}', reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri, parameters('emailFromAddressSecretName')), 'identity', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))), createObject('name', 'storage-account-key', 'keyVaultUrl', format('{0}secrets/{1}', reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri, variables('storageAccountKeySecretName')), 'identity', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName')))), if(variables('includeSmtpSecret'), createArray(createObject('name', 'pds-smtp-secret', 'keyVaultUrl', format('{0}secrets/{1}', reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri, parameters('smtpSecretName')), 'identity', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName')))), createArray()))]"
        },
        "template": {
          "containers": [
            {
              "name": "pds",
              "image": "[variables('pdsImage')]",
              "resources": {
                "cpu": "[json(parameters('pdsCpu'))]",
                "memory": "[parameters('pdsMemory')]"
              },
              "command": [
                "/bin/sh",
                "-c",
                "apk add --no-cache sqlite zstd curl openssl tar gawk; printf \"%s\" \"$RESTORE_SCRIPT_B64\" | base64 -d > /scripts/restore.sh; printf \"%s\" \"$BACKUP_JOB_SCRIPT_B64\" | base64 -d > /scripts/backup-loop.sh; chmod +x /scripts/restore.sh /scripts/backup-loop.sh; /scripts/restore.sh && (/scripts/backup-loop.sh & exec node --enable-source-maps index.js)"
              ],
              "volumeMounts": [
                {
                  "volumeName": "pds-data",
                  "mountPath": "/pds"
                },
                {
                  "volumeName": "scripts",
                  "mountPath": "/scripts"
                }
              ],
              "env": "[concat(createArray(createObject('name', 'PDS_PORT', 'value', '2583'), createObject('name', 'PDS_HOSTNAME', 'value', parameters('pdsHostname')), createObject('name', 'PDS_DATA_DIRECTORY', 'value', '/pds'), createObject('name', 'PDS_ACTOR_STORE_DIRECTORY', 'value', '/pds/actors'), createObject('name', 'PDS_BLOBSTORE_DISK_LOCATION', 'value', '/pds/blobs'), createObject('name', 'PDS_BLOBSTORE_DISK_TMP_LOCATION', 'value', '/pds/blobs/tmp'), createObject('name', 'PDS_BSKY_APP_VIEW_URL', 'value', parameters('pdsBskyAppViewUrl')), createObject('name', 'PDS_BSKY_APP_VIEW_DID', 'value', parameters('pdsBskyAppViewDid')), createObject('name', 'PDS_REPORT_SERVICE_URL', 'value', parameters('pdsReportServiceUrl')), createObject('name', 'PDS_REPORT_SERVICE_DID', 'value', parameters('pdsReportServiceDid')), createObject('name', 'PDS_CRAWLERS', 'value', parameters('pdsCrawlers')), createObject('name', 'PDS_DID_PLC_URL', 'value', parameters('pdsDidPlcUrl')), createObject('name', 'PDS_EMAIL_FROM_ADDRESS', 'secretRef', 'pds-email-from-address'), createObject('name', 'PDS_JWT_SECRET', 'secretRef', 'pds-jwt-secret'), createObject('name', 'PDS_ADMIN_PASSWORD', 'secretRef', 'pds-admin-password'), createObject('name', 'PDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX', 'secretRef', 'pds-plc-key'), createObject('name', 'RESTORE_SCRIPT_B64', 'value', variables('restoreScriptB64')), createObject('name', 'BACKUP_JOB_SCRIPT_B64', 'value', variables('backupJobScriptB64')), createObject('name', 'AZURE_STORAGE_ACCOUNT_NAME', 'value', variables('storageAccountName')), createObject('name', 'AZURE_STORAGE_ACCOUNT_KEY', 'secretRef', 'storage-account-key'), createObject('name', 'SNAPSHOT_CONTAINER', 'value', parameters('snapshotContainerName')), createObject('name', 'SNAPSHOT_PREFIX', 'value', parameters('snapshotPrefix')), createObject('name', 'PDS_ID', 'value', parameters('namePrefix')), createObject('name', 'DATA_DIR', 'value', '/pds'), createObject('name', 'WORK_DIR', 'value', '/work'), createObject('name', 'SENTINEL_PATH', 'value', '/pds/.restore-complete'), createObject('name', 'RETAIN_COUNT', 'value', string(parameters('backupRetentionCount'))), createObject('name', 'INTERVAL_SECONDS', 'value', '300')), if(variables('includeSmtpSecret'), createArray(createObject('name', 'PDS_EMAIL_SMTP_URL', 'secretRef', 'pds-smtp-secret')), createArray()))]"
            }
          ],
          "scale": {
            "minReplicas": 1,
            "maxReplicas": 1
          },
          "volumes": [
            {
              "name": "pds-data",
              "storageType": "EmptyDir"
            },
            {
              "name": "scripts",
              "storageType": "EmptyDir"
            }
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))]",
        "[resourceId('Microsoft.KeyVault/vaults/secrets', variables('keyVaultName'), parameters('emailFromAddressSecretName'))]",
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]",
        "[resourceId('Microsoft.KeyVault/vaults/accessPolicies', variables('keyVaultName'), 'add')]",
        "[resourceId('Microsoft.App/managedEnvironments', variables('managedEnvName'))]",
        "[resourceId('Microsoft.KeyVault/vaults/secrets', variables('keyVaultName'), parameters('smtpSecretName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/accessPolicies",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), 'add')]",
      "properties": {
        "accessPolicies": [
          {
            "tenantId": "[variables('tenantId')]",
            "objectId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName')), '2018-11-30').principalId]",
            "permissions": {
              "secrets": [
                "get",
                "list"
              ]
            }
          }
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))]",
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.Insights/diagnosticSettings",
      "apiVersion": "2021-05-01-preview",
      "scope": "[format('Microsoft.App/containerApps/{0}', variables('containerAppName'))]",
      "name": "[format('{0}-metrics', variables('containerAppName'))]",
      "properties": {
        "workspaceId": "[resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName'))]",
        "metrics": [
          {
            "category": "AllMetrics",
            "enabled": true
          }
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.App/containerApps', variables('containerAppName'))]",
        "[resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName'))]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), variables('storageAccountKeySecretName'))]",
      "properties": {
        "value": "[listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName')), '2022-09-01').keys[0].value]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "scope": "[format('Microsoft.KeyVault/vaults/{0}', variables('keyVaultName'))]",
      "name": "[guid(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName')), '4633458b-17de-408a-b874-0445c86b69e6')]",
      "properties": {
        "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '4633458b-17de-408a-b874-0445c86b69e6')]",
        "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName')), '2018-11-30').principalId]",
        "principalType": "ServicePrincipal"
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', variables('containerAppIdentityName'))]",
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "condition": "[parameters('enableCommunicationServices')]",
      "type": "Microsoft.Communication/emailServices",
      "apiVersion": "2023-04-01",
      "name": "[variables('emailServiceName')]",
      "location": "global",
      "properties": {
        "dataLocation": "United States"
      }
    },
    {
      "condition": "[and(parameters('enableCommunicationServices'), equals(parameters('emailCustomDomain'), ''))]",
      "type": "Microsoft.Communication/emailServices/domains",
      "apiVersion": "2023-04-01",
      "name": "[format('{0}/{1}', variables('emailServiceName'), 'AzureManagedDomain')]",
      "location": "global",
      "properties": {
        "domainManagement": "AzureManaged"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Communication/emailServices', variables('emailServiceName'))]"
      ]
    },
    {
      "condition": "[and(parameters('enableCommunicationServices'), not(equals(parameters('emailCustomDomain'), '')))]",
      "type": "Microsoft.Communication/emailServices/domains",
      "apiVersion": "2023-04-01",
      "name": "[format('{0}/{1}', variables('emailServiceName'), parameters('emailCustomDomain'))]",
      "location": "global",
      "properties": {
        "domainManagement": "CustomerManaged"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Communication/emailServices', variables('emailServiceName'))]"
      ]
    },
    {
      "condition": "[parameters('enableCommunicationServices')]",
      "type": "Microsoft.Communication/communicationServices",
      "apiVersion": "2023-04-01",
      "name": "[variables('communicationServiceName')]",
      "location": "global",
      "properties": {
        "dataLocation": "United States",
        "linkedDomains": [
          "[if(equals(parameters('emailCustomDomain'), ''), resourceId('Microsoft.Communication/emailServices/domains', variables('emailServiceName'), 'AzureManagedDomain'), resourceId('Microsoft.Communication/emailServices/domains', variables('emailServiceName'), parameters('emailCustomDomain')))]"
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.Communication/emailServices/domains', variables('emailServiceName'), parameters('emailCustomDomain'))]",
        "[resourceId('Microsoft.Communication/emailServices/domains', variables('emailServiceName'), 'AzureManagedDomain')]"
      ]
    },
    {
      "condition": "[not(equals(parameters('dnsZoneName'), ''))]",
      "type": "Microsoft.Network/dnsZones",
      "apiVersion": "2023-07-01-preview",
      "name": "[parameters('dnsZoneName')]",
      "location": "global"
    },
    {
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), parameters('emailFromAddressSecretName'))]",
      "properties": {
        "value": "[variables('computedEmailFromAddress')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "condition": "[parameters('enableCommunicationServices')]",
      "type": "Microsoft.KeyVault/vaults/secrets",
      "apiVersion": "2023-07-01",
      "name": "[format('{0}/{1}', variables('keyVaultName'), parameters('smtpSecretName'))]",
      "properties": {
        "value": "[variables('smtpPlaceholderValue')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "condition": "[not(equals(parameters('dnsZoneName'), ''))]",
      "type": "Microsoft.Network/dnsZones/CNAME",
      "apiVersion": "2023-07-01-preview",
      "name": "[format('{0}/{1}', parameters('dnsZoneName'), parameters('dnsRecordName'))]",
      "properties": {
        "TTL": 300,
        "CNAMERecord": {
          "cname": "[reference(resourceId('Microsoft.App/containerApps', variables('containerAppName')), '2023-05-01').configuration.ingress.fqdn]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.App/containerApps', variables('containerAppName'))]",
        "[resourceId('Microsoft.Network/dnsZones', parameters('dnsZoneName'))]"
      ]
    },
    {
      "condition": "[not(equals(parameters('dnsZoneName'), ''))]",
      "type": "Microsoft.Network/dnsZones/CNAME",
      "apiVersion": "2023-07-01-preview",
      "name": "[format('{0}/{1}', parameters('dnsZoneName'), format('*.{0}', parameters('dnsRecordName')))]",
      "properties": {
        "TTL": 300,
        "CNAMERecord": {
          "cname": "[reference(resourceId('Microsoft.App/containerApps', variables('containerAppName')), '2023-05-01').configuration.ingress.fqdn]"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.App/containerApps', variables('containerAppName'))]",
        "[resourceId('Microsoft.Network/dnsZones', parameters('dnsZoneName'))]"
      ]
    },
    {
      "condition": "[not(equals(parameters('dnsZoneName'), ''))]",
      "type": "Microsoft.Network/dnsZones/TXT",
      "apiVersion": "2023-07-01-preview",
      "name": "[format('{0}/{1}', parameters('dnsZoneName'), format('asuid.{0}', parameters('dnsRecordName')))]",
      "properties": {
        "TTL": 300,
        "TXTRecords": [
          {
            "value": [
              "[reference(resourceId('Microsoft.App/containerApps', variables('containerAppName')), '2023-05-01').customDomainVerificationId]"
            ]
          }
        ]
      },
      "dependsOn": [
        "[resourceId('Microsoft.App/containerApps', variables('containerAppName'))]",
        "[resourceId('Microsoft.Network/dnsZones', parameters('dnsZoneName'))]"
      ]
    }
  ],
  "outputs": {
    "containerAppName": {
      "type": "string",
      "value": "[variables('containerAppName')]"
    },
    "containerAppFqdn": {
      "type": "string",
      "value": "[reference(resourceId('Microsoft.App/containerApps', variables('containerAppName')), '2023-05-01').configuration.ingress.fqdn]"
    },
    "storageAccountId": {
      "type": "string",
      "value": "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
    },
    "snapshotContainerResourceId": {
      "type": "string",
      "value": "[resourceId('Microsoft.Storage/storageAccounts/blobServices/containers', split(format('{0}/default/{1}', variables('storageAccountName'), parameters('snapshotContainerName')), '/')[0], split(format('{0}/default/{1}', variables('storageAccountName'), parameters('snapshotContainerName')), '/')[1], split(format('{0}/default/{1}', variables('storageAccountName'), parameters('snapshotContainerName')), '/')[2])]"
    },
    "snapshotContainerName": {
      "type": "string",
      "value": "[parameters('snapshotContainerName')]"
    },
    "keyVaultUri": {
      "type": "string",
      "value": "[reference(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), '2023-07-01').vaultUri]"
    },
    "communicationServiceEndpoint": {
      "type": "string",
      "value": "[if(parameters('enableCommunicationServices'), reference(resourceId('Microsoft.Communication/communicationServices', variables('communicationServiceName')), '2023-04-01').hostName, '')]"
    },
    "emailServiceName": {
      "type": "string",
      "value": "[if(parameters('enableCommunicationServices'), variables('emailServiceName'), '')]"
    },
    "certificateResourceId": {
      "type": "string",
      "value": "[parameters('certificateResourceId')]"
    },
    "containerAppCustomDomainVerificationId": {
      "type": "string",
      "value": "[reference(resourceId('Microsoft.App/containerApps', variables('containerAppName')), '2023-05-01').customDomainVerificationId]"
    },
    "smtpServer": {
      "type": "string",
      "value": "smtp.azurecomm.net"
    },
    "smtpPort": {
      "type": "int",
      "value": 587
    },
    "communicationServiceResourceId": {
      "type": "string",
      "value": "[if(parameters('enableCommunicationServices'), resourceId('Microsoft.Communication/communicationServices', variables('communicationServiceName')), '')]"
    },
    "emailDomainResourceId": {
      "type": "string",
      "value": "[if(parameters('enableCommunicationServices'), if(equals(parameters('emailCustomDomain'), ''), resourceId('Microsoft.Communication/emailServices/domains', variables('emailServiceName'), 'AzureManagedDomain'), resourceId('Microsoft.Communication/emailServices/domains', variables('emailServiceName'), parameters('emailCustomDomain'))), '')]"
    },
    "emailFromAddress": {
      "type": "string",
      "value": "[variables('computedEmailFromAddress')]"
    },
    "keyVaultName": {
      "type": "string",
      "value": "[variables('keyVaultName')]"
    }
  }
}